// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: althea/nativedex/v1/nativedex.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/regen-network/cosmos-proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UpgradeProxyProposal will replace one of the nativedex callpath contracts (or install a new one)
// if passes, calls CrocPolicy.treasuryResolution(CrocSwapDex, 0, <ABI Encoded Bytes(21, <callpath_address>, <callpath_index>)>)
//
// BE VERY CAREFUL EXECUTING THIS PROPOSAL, AS IT CAN COMPLETELY BREAK THE DEX CONTRACT
type UpgradeProxyProposal struct {
	Title       string               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    UpgradeProxyMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
}

func (m *UpgradeProxyProposal) Reset()         { *m = UpgradeProxyProposal{} }
func (m *UpgradeProxyProposal) String() string { return proto.CompactTextString(m) }
func (*UpgradeProxyProposal) ProtoMessage()    {}
func (*UpgradeProxyProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{0}
}
func (m *UpgradeProxyProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeProxyProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeProxyProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeProxyProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeProxyProposal.Merge(m, src)
}
func (m *UpgradeProxyProposal) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeProxyProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeProxyProposal.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeProxyProposal proto.InternalMessageInfo

func (m *UpgradeProxyProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *UpgradeProxyProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UpgradeProxyProposal) GetMetadata() UpgradeProxyMetadata {
	if m != nil {
		return m.Metadata
	}
	return UpgradeProxyMetadata{}
}

type UpgradeProxyMetadata struct {
	CallpathAddress string `protobuf:"bytes,1,opt,name=callpath_address,json=callpathAddress,proto3" json:"callpath_address,omitempty"`
	CallpathIndex   uint64 `protobuf:"varint,2,opt,name=callpath_index,json=callpathIndex,proto3" json:"callpath_index,omitempty"`
}

func (m *UpgradeProxyMetadata) Reset()         { *m = UpgradeProxyMetadata{} }
func (m *UpgradeProxyMetadata) String() string { return proto.CompactTextString(m) }
func (*UpgradeProxyMetadata) ProtoMessage()    {}
func (*UpgradeProxyMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{1}
}
func (m *UpgradeProxyMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeProxyMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeProxyMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeProxyMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeProxyMetadata.Merge(m, src)
}
func (m *UpgradeProxyMetadata) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeProxyMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeProxyMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeProxyMetadata proto.InternalMessageInfo

func (m *UpgradeProxyMetadata) GetCallpathAddress() string {
	if m != nil {
		return m.CallpathAddress
	}
	return ""
}

func (m *UpgradeProxyMetadata) GetCallpathIndex() uint64 {
	if m != nil {
		return m.CallpathIndex
	}
	return 0
}

// CollectTreasuryProposal will pay out protocol fees to the registered (and timelocked) `treasury_` account
// If passes, calls CrocPolicy.treasuryResolution(CrocSwapDex, 3, <ABI Encoded Bytes(40, <token_address>)>)
//
// Note that by default the protocol fees will be set to zero, see the governance history or use CrocQuery with a pool
// to determine the current protocol take
type CollectTreasuryProposal struct {
	Title       string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    CollectTreasuryMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	InSafeMode  bool                    `protobuf:"varint,4,opt,name=in_safe_mode,json=inSafeMode,proto3" json:"in_safe_mode,omitempty"`
}

func (m *CollectTreasuryProposal) Reset()         { *m = CollectTreasuryProposal{} }
func (m *CollectTreasuryProposal) String() string { return proto.CompactTextString(m) }
func (*CollectTreasuryProposal) ProtoMessage()    {}
func (*CollectTreasuryProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{2}
}
func (m *CollectTreasuryProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectTreasuryProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectTreasuryProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectTreasuryProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectTreasuryProposal.Merge(m, src)
}
func (m *CollectTreasuryProposal) XXX_Size() int {
	return m.Size()
}
func (m *CollectTreasuryProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectTreasuryProposal.DiscardUnknown(m)
}

var xxx_messageInfo_CollectTreasuryProposal proto.InternalMessageInfo

func (m *CollectTreasuryProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CollectTreasuryProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CollectTreasuryProposal) GetMetadata() CollectTreasuryMetadata {
	if m != nil {
		return m.Metadata
	}
	return CollectTreasuryMetadata{}
}

func (m *CollectTreasuryProposal) GetInSafeMode() bool {
	if m != nil {
		return m.InSafeMode
	}
	return false
}

type CollectTreasuryMetadata struct {
	TokenAddress string `protobuf:"bytes,1,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
}

func (m *CollectTreasuryMetadata) Reset()         { *m = CollectTreasuryMetadata{} }
func (m *CollectTreasuryMetadata) String() string { return proto.CompactTextString(m) }
func (*CollectTreasuryMetadata) ProtoMessage()    {}
func (*CollectTreasuryMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{3}
}
func (m *CollectTreasuryMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectTreasuryMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectTreasuryMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectTreasuryMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectTreasuryMetadata.Merge(m, src)
}
func (m *CollectTreasuryMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CollectTreasuryMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectTreasuryMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CollectTreasuryMetadata proto.InternalMessageInfo

func (m *CollectTreasuryMetadata) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

// SetTreasuryProposal will change the `treasury_` address
// the treasury_ address will be restricted from receiving protocol fees for a period of time (stored in treasuryStartTime_)
// If passes, calls CrocPolicy.treasuryResolution(CrocSwapDex, 3, <ABI Encoded Bytes(41, <treasury_address>)>)
//
// Note that by default the protocol fees will be set to zero, see the governance history or use CrocQuery with a pool
// to determine the current protocol take
type SetTreasuryProposal struct {
	Title       string              `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string              `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    SetTreasuryMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	InSafeMode  bool                `protobuf:"varint,4,opt,name=in_safe_mode,json=inSafeMode,proto3" json:"in_safe_mode,omitempty"`
}

func (m *SetTreasuryProposal) Reset()         { *m = SetTreasuryProposal{} }
func (m *SetTreasuryProposal) String() string { return proto.CompactTextString(m) }
func (*SetTreasuryProposal) ProtoMessage()    {}
func (*SetTreasuryProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{4}
}
func (m *SetTreasuryProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetTreasuryProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetTreasuryProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetTreasuryProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTreasuryProposal.Merge(m, src)
}
func (m *SetTreasuryProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetTreasuryProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTreasuryProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetTreasuryProposal proto.InternalMessageInfo

func (m *SetTreasuryProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetTreasuryProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetTreasuryProposal) GetMetadata() SetTreasuryMetadata {
	if m != nil {
		return m.Metadata
	}
	return SetTreasuryMetadata{}
}

func (m *SetTreasuryProposal) GetInSafeMode() bool {
	if m != nil {
		return m.InSafeMode
	}
	return false
}

type SetTreasuryMetadata struct {
	TreasuryAddress string `protobuf:"bytes,1,opt,name=treasury_address,json=treasuryAddress,proto3" json:"treasury_address,omitempty"`
}

func (m *SetTreasuryMetadata) Reset()         { *m = SetTreasuryMetadata{} }
func (m *SetTreasuryMetadata) String() string { return proto.CompactTextString(m) }
func (*SetTreasuryMetadata) ProtoMessage()    {}
func (*SetTreasuryMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{5}
}
func (m *SetTreasuryMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetTreasuryMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetTreasuryMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetTreasuryMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTreasuryMetadata.Merge(m, src)
}
func (m *SetTreasuryMetadata) XXX_Size() int {
	return m.Size()
}
func (m *SetTreasuryMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTreasuryMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_SetTreasuryMetadata proto.InternalMessageInfo

func (m *SetTreasuryMetadata) GetTreasuryAddress() string {
	if m != nil {
		return m.TreasuryAddress
	}
	return ""
}

// AuthorityTransferProposal will change the `authority_` address, which can be used to upgrade or remove the CrocPolicy
// contract (and therefore this module must be upgraded to work with the replacement, and configured as the new authority)
// If passes, calls CrocPolicy.treasuryResolution(CrocSwapDex, 3, <ABI Encoded Bytes(20, <auth_address>)>)
//
// BE VERY CAREFUL EXECUTING THIS PROPOSAL, AS IT CAN COMPLETELY DISABLE THE NATIVEDEX MODULE AND REMOVE STAKER AUTHORITY
// OVER THE DEX CONTRACT
type AuthorityTransferProposal struct {
	Title       string                    `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string                    `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    AuthorityTransferMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	InSafeMode  bool                      `protobuf:"varint,4,opt,name=in_safe_mode,json=inSafeMode,proto3" json:"in_safe_mode,omitempty"`
}

func (m *AuthorityTransferProposal) Reset()         { *m = AuthorityTransferProposal{} }
func (m *AuthorityTransferProposal) String() string { return proto.CompactTextString(m) }
func (*AuthorityTransferProposal) ProtoMessage()    {}
func (*AuthorityTransferProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{6}
}
func (m *AuthorityTransferProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorityTransferProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorityTransferProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorityTransferProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorityTransferProposal.Merge(m, src)
}
func (m *AuthorityTransferProposal) XXX_Size() int {
	return m.Size()
}
func (m *AuthorityTransferProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorityTransferProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorityTransferProposal proto.InternalMessageInfo

func (m *AuthorityTransferProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AuthorityTransferProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AuthorityTransferProposal) GetMetadata() AuthorityTransferMetadata {
	if m != nil {
		return m.Metadata
	}
	return AuthorityTransferMetadata{}
}

func (m *AuthorityTransferProposal) GetInSafeMode() bool {
	if m != nil {
		return m.InSafeMode
	}
	return false
}

type AuthorityTransferMetadata struct {
	AuthAddress string `protobuf:"bytes,1,opt,name=auth_address,json=authAddress,proto3" json:"auth_address,omitempty"`
}

func (m *AuthorityTransferMetadata) Reset()         { *m = AuthorityTransferMetadata{} }
func (m *AuthorityTransferMetadata) String() string { return proto.CompactTextString(m) }
func (*AuthorityTransferMetadata) ProtoMessage()    {}
func (*AuthorityTransferMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{7}
}
func (m *AuthorityTransferMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorityTransferMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorityTransferMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorityTransferMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorityTransferMetadata.Merge(m, src)
}
func (m *AuthorityTransferMetadata) XXX_Size() int {
	return m.Size()
}
func (m *AuthorityTransferMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorityTransferMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorityTransferMetadata proto.InternalMessageInfo

func (m *AuthorityTransferMetadata) GetAuthAddress() string {
	if m != nil {
		return m.AuthAddress
	}
	return ""
}

// HotPathOpenProposal will change the `hotPathOpen_` flag, which controls if users are able to call swap directly on the dex contract
// The primary purpose of this seems to be enabling upgradeability of the HotProxy contract, which would require users to switch
// to calling CrocSwapDex.userCmd(1, <ABI Encoded Args>) instead of CrocSwapDex.swap(<args>) so that they call the new code.
// If passes, calls CrocPolicy.treasuryResolution(CrocSwapDex, 3, <ABI Encoded Bytes(22, <open>)>)
//
// BE VERY CAREFUL EXECUTING THIS PROPOSAL, AS IT CAN BREAK INFLEXIBLE DEX USER INTERFACES
type HotPathOpenProposal struct {
	Title       string              `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string              `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    HotPathOpenMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	InSafeMode  bool                `protobuf:"varint,4,opt,name=in_safe_mode,json=inSafeMode,proto3" json:"in_safe_mode,omitempty"`
}

func (m *HotPathOpenProposal) Reset()         { *m = HotPathOpenProposal{} }
func (m *HotPathOpenProposal) String() string { return proto.CompactTextString(m) }
func (*HotPathOpenProposal) ProtoMessage()    {}
func (*HotPathOpenProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{8}
}
func (m *HotPathOpenProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotPathOpenProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HotPathOpenProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HotPathOpenProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotPathOpenProposal.Merge(m, src)
}
func (m *HotPathOpenProposal) XXX_Size() int {
	return m.Size()
}
func (m *HotPathOpenProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_HotPathOpenProposal.DiscardUnknown(m)
}

var xxx_messageInfo_HotPathOpenProposal proto.InternalMessageInfo

func (m *HotPathOpenProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *HotPathOpenProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *HotPathOpenProposal) GetMetadata() HotPathOpenMetadata {
	if m != nil {
		return m.Metadata
	}
	return HotPathOpenMetadata{}
}

func (m *HotPathOpenProposal) GetInSafeMode() bool {
	if m != nil {
		return m.InSafeMode
	}
	return false
}

type HotPathOpenMetadata struct {
	// If true, users can call swap directly on the dex contract.
	// If false, they must call CrocSwapDex.userCmd(1, <ABI Encoded Args>)
	Open bool `protobuf:"varint,1,opt,name=open,proto3" json:"open,omitempty"`
}

func (m *HotPathOpenMetadata) Reset()         { *m = HotPathOpenMetadata{} }
func (m *HotPathOpenMetadata) String() string { return proto.CompactTextString(m) }
func (*HotPathOpenMetadata) ProtoMessage()    {}
func (*HotPathOpenMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{9}
}
func (m *HotPathOpenMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotPathOpenMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HotPathOpenMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HotPathOpenMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotPathOpenMetadata.Merge(m, src)
}
func (m *HotPathOpenMetadata) XXX_Size() int {
	return m.Size()
}
func (m *HotPathOpenMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_HotPathOpenMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_HotPathOpenMetadata proto.InternalMessageInfo

func (m *HotPathOpenMetadata) GetOpen() bool {
	if m != nil {
		return m.Open
	}
	return false
}

// SetSafeModeProposal will lock down the DEX for emergency changes. This can also be used by the emergency multisig to halt the DEX more quickly.
// When the DEX is in safe mode only a UpgradeProxy, CollectTreasury, SetTreasury, AuthorityTransfer, HotPathOpen, or SetSafeMode Proposal can be executed,
// and these proposals can only be executed under the SafeMode or Boot Proxy callpaths.
// If passes, calls CrocPolicy.treasuryResolution(CrocSwapDex, 3, <ABI Encoded Bytes(23, <lock_dex>)>)
//
// BE VERY CAREFUL EXECUTING THIS PROPOSAL, IT SHOULD ONLY BE USED TO DISABLE THE DEX OR RECOVER FROM DISABLES
type SetSafeModeProposal struct {
	Title       string              `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string              `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    SetSafeModeMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	InSafeMode  bool                `protobuf:"varint,4,opt,name=in_safe_mode,json=inSafeMode,proto3" json:"in_safe_mode,omitempty"`
}

func (m *SetSafeModeProposal) Reset()         { *m = SetSafeModeProposal{} }
func (m *SetSafeModeProposal) String() string { return proto.CompactTextString(m) }
func (*SetSafeModeProposal) ProtoMessage()    {}
func (*SetSafeModeProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{10}
}
func (m *SetSafeModeProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSafeModeProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSafeModeProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSafeModeProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSafeModeProposal.Merge(m, src)
}
func (m *SetSafeModeProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetSafeModeProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSafeModeProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetSafeModeProposal proto.InternalMessageInfo

func (m *SetSafeModeProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetSafeModeProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetSafeModeProposal) GetMetadata() SetSafeModeMetadata {
	if m != nil {
		return m.Metadata
	}
	return SetSafeModeMetadata{}
}

func (m *SetSafeModeProposal) GetInSafeMode() bool {
	if m != nil {
		return m.InSafeMode
	}
	return false
}

type SetSafeModeMetadata struct {
	// If true, the DEX will be disabled
	LockDex bool `protobuf:"varint,1,opt,name=lock_dex,json=lockDex,proto3" json:"lock_dex,omitempty"`
}

func (m *SetSafeModeMetadata) Reset()         { *m = SetSafeModeMetadata{} }
func (m *SetSafeModeMetadata) String() string { return proto.CompactTextString(m) }
func (*SetSafeModeMetadata) ProtoMessage()    {}
func (*SetSafeModeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{11}
}
func (m *SetSafeModeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSafeModeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSafeModeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSafeModeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSafeModeMetadata.Merge(m, src)
}
func (m *SetSafeModeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *SetSafeModeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSafeModeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_SetSafeModeMetadata proto.InternalMessageInfo

func (m *SetSafeModeMetadata) GetLockDex() bool {
	if m != nil {
		return m.LockDex
	}
	return false
}

// TransferGovernanceProposal will update the governance role addresses on CrocPolicy.
// If passes, calls CrocPolicy.transferGovernance(<ops>, <nativedex module address>, <emergency>)
//
// BE VERY CAREFUL EXECUTING THIS PROPOSAL, THE OPS AND EMERGENCY ADDRESSES SHOULD BE CAREFULLY CHOSEN MULTISIGS
type TransferGovernanceProposal struct {
	Title       string                     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string                     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    TransferGovernanceMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
}

func (m *TransferGovernanceProposal) Reset()         { *m = TransferGovernanceProposal{} }
func (m *TransferGovernanceProposal) String() string { return proto.CompactTextString(m) }
func (*TransferGovernanceProposal) ProtoMessage()    {}
func (*TransferGovernanceProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{12}
}
func (m *TransferGovernanceProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferGovernanceProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferGovernanceProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferGovernanceProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferGovernanceProposal.Merge(m, src)
}
func (m *TransferGovernanceProposal) XXX_Size() int {
	return m.Size()
}
func (m *TransferGovernanceProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferGovernanceProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TransferGovernanceProposal proto.InternalMessageInfo

func (m *TransferGovernanceProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *TransferGovernanceProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TransferGovernanceProposal) GetMetadata() TransferGovernanceMetadata {
	if m != nil {
		return m.Metadata
	}
	return TransferGovernanceMetadata{}
}

type TransferGovernanceMetadata struct {
	Ops       string `protobuf:"bytes,1,opt,name=ops,proto3" json:"ops,omitempty"`
	Emergency string `protobuf:"bytes,2,opt,name=emergency,proto3" json:"emergency,omitempty"`
}

func (m *TransferGovernanceMetadata) Reset()         { *m = TransferGovernanceMetadata{} }
func (m *TransferGovernanceMetadata) String() string { return proto.CompactTextString(m) }
func (*TransferGovernanceMetadata) ProtoMessage()    {}
func (*TransferGovernanceMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{13}
}
func (m *TransferGovernanceMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferGovernanceMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferGovernanceMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferGovernanceMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferGovernanceMetadata.Merge(m, src)
}
func (m *TransferGovernanceMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TransferGovernanceMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferGovernanceMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TransferGovernanceMetadata proto.InternalMessageInfo

func (m *TransferGovernanceMetadata) GetOps() string {
	if m != nil {
		return m.Ops
	}
	return ""
}

func (m *TransferGovernanceMetadata) GetEmergency() string {
	if m != nil {
		return m.Emergency
	}
	return ""
}

// OpsProposal will execute a non-sudo `protocolCmd()` call on the DEX via CrocPolicy.
// If passes, calls CrocPolicy.opsResolution (CrocSwapDex, <callpath>, <ABI Encoded Bytes(<cmd args>)>)
//
// This proposal enables nativedex governance to perform everyday Ops functions on the DEX,
// and so the Ops or Emergency addresses could override any decisions made by this proposal.
type OpsProposal struct {
	Title       string      `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string      `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    OpsMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
}

func (m *OpsProposal) Reset()         { *m = OpsProposal{} }
func (m *OpsProposal) String() string { return proto.CompactTextString(m) }
func (*OpsProposal) ProtoMessage()    {}
func (*OpsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{14}
}
func (m *OpsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpsProposal.Merge(m, src)
}
func (m *OpsProposal) XXX_Size() int {
	return m.Size()
}
func (m *OpsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_OpsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_OpsProposal proto.InternalMessageInfo

func (m *OpsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *OpsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpsProposal) GetMetadata() OpsMetadata {
	if m != nil {
		return m.Metadata
	}
	return OpsMetadata{}
}

type OpsMetadata struct {
	Callpath uint64 `protobuf:"varint,1,opt,name=callpath,proto3" json:"callpath,omitempty"`
	CmdArgs  []byte `protobuf:"bytes,2,opt,name=cmd_args,json=cmdArgs,proto3" json:"cmd_args,omitempty"`
}

func (m *OpsMetadata) Reset()         { *m = OpsMetadata{} }
func (m *OpsMetadata) String() string { return proto.CompactTextString(m) }
func (*OpsMetadata) ProtoMessage()    {}
func (*OpsMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a3d4c3de1cf69d0, []int{15}
}
func (m *OpsMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpsMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpsMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpsMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpsMetadata.Merge(m, src)
}
func (m *OpsMetadata) XXX_Size() int {
	return m.Size()
}
func (m *OpsMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_OpsMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_OpsMetadata proto.InternalMessageInfo

func (m *OpsMetadata) GetCallpath() uint64 {
	if m != nil {
		return m.Callpath
	}
	return 0
}

func (m *OpsMetadata) GetCmdArgs() []byte {
	if m != nil {
		return m.CmdArgs
	}
	return nil
}

func init() {
	proto.RegisterType((*UpgradeProxyProposal)(nil), "althea.nativedex.v1.UpgradeProxyProposal")
	proto.RegisterType((*UpgradeProxyMetadata)(nil), "althea.nativedex.v1.UpgradeProxyMetadata")
	proto.RegisterType((*CollectTreasuryProposal)(nil), "althea.nativedex.v1.CollectTreasuryProposal")
	proto.RegisterType((*CollectTreasuryMetadata)(nil), "althea.nativedex.v1.CollectTreasuryMetadata")
	proto.RegisterType((*SetTreasuryProposal)(nil), "althea.nativedex.v1.SetTreasuryProposal")
	proto.RegisterType((*SetTreasuryMetadata)(nil), "althea.nativedex.v1.SetTreasuryMetadata")
	proto.RegisterType((*AuthorityTransferProposal)(nil), "althea.nativedex.v1.AuthorityTransferProposal")
	proto.RegisterType((*AuthorityTransferMetadata)(nil), "althea.nativedex.v1.AuthorityTransferMetadata")
	proto.RegisterType((*HotPathOpenProposal)(nil), "althea.nativedex.v1.HotPathOpenProposal")
	proto.RegisterType((*HotPathOpenMetadata)(nil), "althea.nativedex.v1.HotPathOpenMetadata")
	proto.RegisterType((*SetSafeModeProposal)(nil), "althea.nativedex.v1.SetSafeModeProposal")
	proto.RegisterType((*SetSafeModeMetadata)(nil), "althea.nativedex.v1.SetSafeModeMetadata")
	proto.RegisterType((*TransferGovernanceProposal)(nil), "althea.nativedex.v1.TransferGovernanceProposal")
	proto.RegisterType((*TransferGovernanceMetadata)(nil), "althea.nativedex.v1.TransferGovernanceMetadata")
	proto.RegisterType((*OpsProposal)(nil), "althea.nativedex.v1.OpsProposal")
	proto.RegisterType((*OpsMetadata)(nil), "althea.nativedex.v1.OpsMetadata")
}

func init() {
	proto.RegisterFile("althea/nativedex/v1/nativedex.proto", fileDescriptor_8a3d4c3de1cf69d0)
}

var fileDescriptor_8a3d4c3de1cf69d0 = []byte{
	// 718 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x96, 0x4d, 0x4f, 0x13, 0x41,
	0x18, 0xc7, 0xbb, 0x50, 0xa5, 0x4c, 0x8b, 0x92, 0x85, 0xc4, 0xb6, 0x31, 0xa5, 0x42, 0x4c, 0x4a,
	0x22, 0xdd, 0x54, 0x13, 0x35, 0x9c, 0x2c, 0x10, 0x54, 0x14, 0x29, 0x0b, 0x5e, 0xbc, 0x34, 0xc3,
	0xee, 0xc3, 0x76, 0xc3, 0xee, 0xcc, 0x66, 0x66, 0xda, 0xb4, 0x1f, 0xc0, 0x83, 0x37, 0x3f, 0x82,
	0x1f, 0xc2, 0x0f, 0x41, 0xe2, 0x85, 0x78, 0xf2, 0xa2, 0x31, 0x70, 0xd1, 0x0f, 0x61, 0x62, 0xf6,
	0x95, 0x2d, 0xbb, 0x9c, 0x0a, 0xf4, 0xd4, 0x79, 0xfe, 0x33, 0xdd, 0xe7, 0xf9, 0xff, 0xf2, 0xcc,
	0x0b, 0x5a, 0xc2, 0x96, 0xe8, 0x00, 0x56, 0x08, 0x16, 0x66, 0x0f, 0x74, 0xe8, 0x2b, 0xbd, 0xc6,
	0x79, 0x50, 0x77, 0x18, 0x15, 0x54, 0x9e, 0xf3, 0x17, 0xd5, 0xcf, 0xf5, 0x5e, 0xa3, 0x3c, 0x6f,
	0x50, 0x83, 0x7a, 0xf3, 0x8a, 0x3b, 0xf2, 0x97, 0x96, 0x4b, 0x1a, 0xe5, 0x36, 0xe5, 0x6d, 0x7f,
	0xc2, 0x0f, 0xfc, 0xa9, 0xc5, 0x9f, 0x12, 0x9a, 0x7f, 0xef, 0x18, 0x0c, 0xeb, 0xd0, 0x62, 0xb4,
	0x3f, 0x68, 0x31, 0xea, 0x50, 0x8e, 0x2d, 0x79, 0x1e, 0xdd, 0x12, 0xa6, 0xb0, 0xa0, 0x28, 0x55,
	0xa5, 0xda, 0xb4, 0xea, 0x07, 0x72, 0x15, 0xe5, 0x75, 0xe0, 0x1a, 0x33, 0x1d, 0x61, 0x52, 0x52,
	0x9c, 0xf0, 0xe6, 0xe2, 0x92, 0xfc, 0x06, 0xe5, 0x6c, 0x10, 0x58, 0xc7, 0x02, 0x17, 0x27, 0xab,
	0x52, 0x2d, 0xff, 0x78, 0xb9, 0x9e, 0x52, 0x69, 0x3d, 0x9e, 0x74, 0x3b, 0xf8, 0xc3, 0x5a, 0xf6,
	0xf8, 0xd7, 0x42, 0x46, 0x8d, 0x3e, 0xb0, 0xfa, 0xe2, 0xcf, 0x97, 0x85, 0xcc, 0xf7, 0xaf, 0x2b,
	0xcf, 0x0d, 0x53, 0x74, 0xba, 0x07, 0x75, 0x8d, 0xda, 0x41, 0xf9, 0xc1, 0xcf, 0x0a, 0xd7, 0x8f,
	0x94, 0xbe, 0x62, 0xd0, 0x9e, 0x22, 0x06, 0x0e, 0x70, 0xa5, 0xd7, 0x38, 0x00, 0x81, 0x1b, 0xf5,
	0x75, 0x4a, 0x04, 0x10, 0xb1, 0x48, 0x86, 0xed, 0x85, 0x99, 0xe4, 0x65, 0x34, 0xab, 0x61, 0xcb,
	0x72, 0xb0, 0xe8, 0xb4, 0xb1, 0xae, 0x33, 0xe0, 0x3c, 0x70, 0x7a, 0x37, 0xd4, 0x9b, 0xbe, 0x2c,
	0x3f, 0x44, 0x77, 0xa2, 0xa5, 0x26, 0xd1, 0xa1, 0xef, 0xd9, 0xce, 0xaa, 0x33, 0xa1, 0xfa, 0xda,
	0x15, 0x57, 0xb3, 0x6e, 0xad, 0x8b, 0x1f, 0x27, 0xd0, 0xbd, 0x75, 0x6a, 0x59, 0xa0, 0x89, 0x7d,
	0x06, 0x98, 0x77, 0xd9, 0xe8, 0x48, 0xdf, 0x25, 0x90, 0x3e, 0x4a, 0x45, 0x7a, 0x21, 0xef, 0x65,
	0x54, 0xe5, 0x2a, 0x2a, 0x98, 0xa4, 0xcd, 0xf1, 0x21, 0xb4, 0x6d, 0xaa, 0x43, 0x31, 0x5b, 0x95,
	0x6a, 0x39, 0x15, 0x99, 0x64, 0x0f, 0x1f, 0xc2, 0x36, 0xd5, 0xe1, 0x0a, 0xb8, 0x6f, 0x24, 0x30,
	0x44, 0xe8, 0x97, 0xd0, 0x8c, 0xa0, 0x47, 0x40, 0x2e, 0x70, 0x2f, 0x78, 0x62, 0x00, 0x3d, 0xa0,
	0xf9, 0x4f, 0x42, 0x73, 0x7b, 0x70, 0x75, 0x24, 0xb7, 0x12, 0x24, 0x6b, 0xa9, 0x24, 0x63, 0x39,
	0xc7, 0x4a, 0x71, 0x73, 0xc8, 0x7e, 0xbc, 0x79, 0x45, 0xa0, 0x5d, 0x6c, 0xde, 0x50, 0x1f, 0xe6,
	0xf8, 0x69, 0x02, 0x95, 0x9a, 0x5d, 0xd1, 0xa1, 0xcc, 0x14, 0x83, 0x7d, 0x86, 0x09, 0x3f, 0x04,
	0x36, 0x32, 0xcd, 0x56, 0x82, 0x66, 0x3d, 0x95, 0x66, 0x22, 0xf3, 0x98, 0x3b, 0xb3, 0x74, 0x69,
	0x41, 0xf2, 0x03, 0x54, 0xc0, 0xdd, 0xc4, 0x91, 0x90, 0x77, 0xb5, 0x64, 0x67, 0xbe, 0xa2, 0xa2,
	0x85, 0x45, 0x67, 0xc7, 0x01, 0x72, 0x63, 0x9d, 0x19, 0xcb, 0x39, 0x56, 0x8a, 0xca, 0x90, 0xfd,
	0x88, 0x9f, 0x8c, 0xb2, 0xd4, 0x01, 0xe2, 0xb9, 0xcf, 0xa9, 0xde, 0x78, 0x78, 0x2b, 0x87, 0x25,
	0xdc, 0xe4, 0x56, 0x0e, 0x73, 0x8e, 0x15, 0xd8, 0xd3, 0x21, 0xfb, 0x11, 0xb0, 0x12, 0xca, 0x59,
	0x54, 0x3b, 0x6a, 0xbb, 0xd7, 0x8a, 0x0f, 0x6d, 0xca, 0x8d, 0x37, 0xa2, 0x0b, 0xe5, 0xaf, 0x84,
	0xca, 0x61, 0x9b, 0xbe, 0xa4, 0x3d, 0x60, 0x04, 0x13, 0x6d, 0x74, 0x7c, 0xbb, 0x09, 0x7c, 0x4a,
	0x2a, 0xbe, 0x64, 0xea, 0x6b, 0xbc, 0xac, 0xd5, 0x34, 0xab, 0x11, 0xaa, 0x59, 0x34, 0x49, 0x9d,
	0x70, 0x4b, 0xba, 0x43, 0xf9, 0x3e, 0x9a, 0x06, 0x1b, 0x98, 0x01, 0x44, 0x1b, 0x04, 0x26, 0xcf,
	0x85, 0x80, 0xdf, 0x37, 0x09, 0xe5, 0x77, 0x1c, 0x3e, 0x32, 0xb0, 0xb5, 0x04, 0xb0, 0x6a, 0x2a,
	0xb0, 0x1d, 0x87, 0x5f, 0x23, 0xa1, 0x2d, 0xcf, 0x4c, 0x84, 0xa4, 0x8c, 0x72, 0xe1, 0x23, 0xc4,
	0xf3, 0x93, 0x55, 0xa3, 0xd8, 0xed, 0x2c, 0xcd, 0xd6, 0xdb, 0x98, 0x19, 0xdc, 0xf3, 0x53, 0x50,
	0xa7, 0x34, 0x5b, 0x6f, 0x32, 0x23, 0x38, 0xc2, 0xd6, 0x76, 0x8f, 0x4f, 0x2b, 0xd2, 0xc9, 0x69,
	0x45, 0xfa, 0x7d, 0x5a, 0x91, 0x3e, 0x9f, 0x55, 0x32, 0x27, 0x67, 0x95, 0xcc, 0x8f, 0xb3, 0x4a,
	0xe6, 0xc3, 0xb3, 0x58, 0x7d, 0x4d, 0xcf, 0xe3, 0x26, 0xed, 0x12, 0x1d, 0xbb, 0x20, 0x14, 0xdf,
	0xf4, 0xca, 0xdb, 0x86, 0xd2, 0x8f, 0x3d, 0x50, 0xbd, 0x72, 0x0f, 0x6e, 0x7b, 0x8f, 0xca, 0x27,
	0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x9f, 0x54, 0xf0, 0xc1, 0x0a, 0x00, 0x00,
}

func (m *UpgradeProxyProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeProxyProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeProxyProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeProxyMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeProxyMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeProxyMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CallpathIndex != 0 {
		i = encodeVarintNativedex(dAtA, i, uint64(m.CallpathIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CallpathAddress) > 0 {
		i -= len(m.CallpathAddress)
		copy(dAtA[i:], m.CallpathAddress)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.CallpathAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectTreasuryProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectTreasuryProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectTreasuryProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InSafeMode {
		i--
		if m.InSafeMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectTreasuryMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectTreasuryMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectTreasuryMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenAddress) > 0 {
		i -= len(m.TokenAddress)
		copy(dAtA[i:], m.TokenAddress)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.TokenAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetTreasuryProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTreasuryProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetTreasuryProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InSafeMode {
		i--
		if m.InSafeMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetTreasuryMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTreasuryMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetTreasuryMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TreasuryAddress) > 0 {
		i -= len(m.TreasuryAddress)
		copy(dAtA[i:], m.TreasuryAddress)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.TreasuryAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorityTransferProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorityTransferProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorityTransferProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InSafeMode {
		i--
		if m.InSafeMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorityTransferMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorityTransferMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorityTransferMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthAddress) > 0 {
		i -= len(m.AuthAddress)
		copy(dAtA[i:], m.AuthAddress)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.AuthAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HotPathOpenProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotPathOpenProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotPathOpenProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InSafeMode {
		i--
		if m.InSafeMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HotPathOpenMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotPathOpenMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotPathOpenMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Open {
		i--
		if m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetSafeModeProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSafeModeProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSafeModeProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InSafeMode {
		i--
		if m.InSafeMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetSafeModeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSafeModeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSafeModeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LockDex {
		i--
		if m.LockDex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferGovernanceProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferGovernanceProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferGovernanceProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferGovernanceMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferGovernanceMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferGovernanceMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Emergency) > 0 {
		i -= len(m.Emergency)
		copy(dAtA[i:], m.Emergency)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Emergency)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ops) > 0 {
		i -= len(m.Ops)
		copy(dAtA[i:], m.Ops)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Ops)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNativedex(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpsMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpsMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpsMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CmdArgs) > 0 {
		i -= len(m.CmdArgs)
		copy(dAtA[i:], m.CmdArgs)
		i = encodeVarintNativedex(dAtA, i, uint64(len(m.CmdArgs)))
		i--
		dAtA[i] = 0x12
	}
	if m.Callpath != 0 {
		i = encodeVarintNativedex(dAtA, i, uint64(m.Callpath))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNativedex(dAtA []byte, offset int, v uint64) int {
	offset -= sovNativedex(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpgradeProxyProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	return n
}

func (m *UpgradeProxyMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CallpathAddress)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	if m.CallpathIndex != 0 {
		n += 1 + sovNativedex(uint64(m.CallpathIndex))
	}
	return n
}

func (m *CollectTreasuryProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	if m.InSafeMode {
		n += 2
	}
	return n
}

func (m *CollectTreasuryMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenAddress)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	return n
}

func (m *SetTreasuryProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	if m.InSafeMode {
		n += 2
	}
	return n
}

func (m *SetTreasuryMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreasuryAddress)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	return n
}

func (m *AuthorityTransferProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	if m.InSafeMode {
		n += 2
	}
	return n
}

func (m *AuthorityTransferMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthAddress)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	return n
}

func (m *HotPathOpenProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	if m.InSafeMode {
		n += 2
	}
	return n
}

func (m *HotPathOpenMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open {
		n += 2
	}
	return n
}

func (m *SetSafeModeProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	if m.InSafeMode {
		n += 2
	}
	return n
}

func (m *SetSafeModeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockDex {
		n += 2
	}
	return n
}

func (m *TransferGovernanceProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	return n
}

func (m *TransferGovernanceMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ops)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Emergency)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	return n
}

func (m *OpsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovNativedex(uint64(l))
	return n
}

func (m *OpsMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Callpath != 0 {
		n += 1 + sovNativedex(uint64(m.Callpath))
	}
	l = len(m.CmdArgs)
	if l > 0 {
		n += 1 + l + sovNativedex(uint64(l))
	}
	return n
}

func sovNativedex(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNativedex(x uint64) (n int) {
	return sovNativedex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpgradeProxyProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeProxyProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeProxyProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeProxyMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeProxyMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeProxyMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallpathAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallpathAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallpathIndex", wireType)
			}
			m.CallpathIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallpathIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectTreasuryProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectTreasuryProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectTreasuryProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSafeMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSafeMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectTreasuryMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectTreasuryMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectTreasuryMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTreasuryProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTreasuryProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTreasuryProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSafeMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSafeMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTreasuryMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTreasuryMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTreasuryMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorityTransferProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorityTransferProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorityTransferProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSafeMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSafeMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorityTransferMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorityTransferMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorityTransferMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotPathOpenProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotPathOpenProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotPathOpenProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSafeMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSafeMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotPathOpenMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotPathOpenMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotPathOpenMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSafeModeProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSafeModeProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSafeModeProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSafeMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSafeMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSafeModeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSafeModeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSafeModeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockDex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockDex = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferGovernanceProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferGovernanceProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferGovernanceProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferGovernanceMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferGovernanceMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferGovernanceMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emergency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emergency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpsMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpsMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpsMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callpath", wireType)
			}
			m.Callpath = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Callpath |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdArgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNativedex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNativedex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdArgs = append(m.CmdArgs[:0], dAtA[iNdEx:postIndex]...)
			if m.CmdArgs == nil {
				m.CmdArgs = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNativedex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNativedex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNativedex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNativedex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNativedex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNativedex
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNativedex
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNativedex
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNativedex        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNativedex          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNativedex = fmt.Errorf("proto: unexpected end of group")
)
